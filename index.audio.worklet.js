class RingBuffer{constructor(a,b){this.buffer=a,this.avail=b,this.rpos=0,this.wpos=0}data_left(){return Atomics.load(this.avail,0)}space_left(){return this.buffer.length-this.data_left()}read(a){const c=this.buffer.length;let d=0,b=a.length;if(this.rpos+b>c){const e=c-this.rpos;a.set(this.buffer.subarray(this.rpos,c)),d=e,b-=e,this.rpos=0}a.set(this.buffer.subarray(this.rpos,this.rpos+b),d),this.rpos+=b,Atomics.add(this.avail,0,-a.length),Atomics.notify(this.avail,0)}write(b){const a=b.length,c=this.buffer.length-this.wpos;if(c>=a)this.buffer.set(b,this.wpos);else{const d=b.subarray(0,a-c),e=b.subarray(a-c);this.buffer.set(d,this.wpos),this.buffer.set(e)}let d=a;this.wpos+d>=this.buffer.length&&(d-=this.buffer.length),this.wpos+=d,Atomics.add(this.avail,0,a),Atomics.notify(this.avail,0)}}class GodotProcessor extends AudioWorkletProcessor{constructor(){super(),this.running=!0,this.lock=null,this.notifier=null,this.output=null,this.output_buffer=new Float32Array,this.input=null,this.input_buffer=new Float32Array,this.port.onmessage=a=>{const b=a.data.cmd,c=a.data.data;this.parse_message(b,c)}}process_notify(){Atomics.add(this.notifier,0,1),Atomics.notify(this.notifier,0)}parse_message(b,a){if(b==='start'&&a){const c=a[0];let b=0;this.lock=c.subarray(b,++b),this.notifier=c.subarray(b,++b);const d=c.subarray(b,++b),e=c.subarray(b,++b);this.input=new RingBuffer(a[1],d),this.output=new RingBuffer(a[2],e)}else b==='stop'&&(this.runing=!1,this.output=null,this.input=null)}static array_has_data(a){return a.length&&a[0].length&&a[0][0].length}process(a,b,e){if(!this.running)return!1;if(this.output===null)return!0;const c=GodotProcessor.array_has_data(a);if(c){const b=a[0],c=b[0].length*b.length;this.input_buffer.length!==c&&(this.input_buffer=new Float32Array(c)),this.input.space_left()>=c?(GodotProcessor.write_input(this.input_buffer,b),this.input.write(this.input_buffer)):this.port.postMessage('Input buffer is full! Skipping input frame.')}const d=GodotProcessor.array_has_data(b);if(d){const a=b[0],c=a[0].length*a.length;this.output_buffer.length!==c&&(this.output_buffer=new Float32Array(c)),this.output.data_left()>=c?(this.output.read(this.output_buffer),GodotProcessor.write_output(a,this.output_buffer)):this.port.postMessage('Output buffer has not enough frames! Skipping output frame.')}return this.process_notify(),!0}static write_output(a,c){const b=a.length;for(let d=0;d<b;d++)for(let e=0;e<a[d].length;e++)a[d][e]=c[e*b+d]}static write_input(c,a){const b=a.length;for(let d=0;d<b;d++)for(let e=0;e<a[d].length;e++)c[e*b+d]=a[d][e]}}registerProcessor('godot-processor',GodotProcessor)